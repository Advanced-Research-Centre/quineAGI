## Quine

A quine is a non-empty computer program which takes no input and produces a copy of its own source code as its only output. The standard terms for these programs in the computability theory and computer science literature are "self-replicating programs", "self-reproducing programs", and "self-copying programs".

A quine is a fixed point of an execution environment, when the execution environment is viewed as a function transforming programs into their outputs. Quines are possible in any Turing complete programming language, as a direct consequence of Kleene's recursion theorem.

The name "quine" was coined by Douglas Hofstadter, in his popular science book Gödel, Escher, Bach: An Eternal Golden Braid, in honor of philosopher Willard Van Orman Quine.

## Types

The quine concept can be extended to multiple levels or recursion, originating "ouroboros programs", or quine-relays.

A multiquine is a set of r different programs (in r different languages — without this condition we could take them all equal to a single quine), each of which is able to print any of the r programs (including itself) according to the command line argument it is passed.

A radiation-hardened quine is a quine that can have any single character removed and still produce the original program with no missing character.

## 2 parts of a Quine

In principle, any program can be written as a quine, where it
1. replicates  it  source  code
2. executes an orthogonal payload which serves the same purpose the  original  non-quine  version.

## 5 layers of Recursion

There are 5 layers in the quine evolution:
1. The premise of the program execution is generated with a script file. It allows various programs to interact with file write/read (payloads delivery). It models the biosphere.
2. The top-most level deals with evolution. The DNA of the quine code evolves in specific places (an analogy to chromosomes). These include the non-fatal organization structure (number of cells of each type encoded in the matrix), and parameters (like speed or algorithm of the meta-learning algorithms of level 3 & 4).
3. The invention level corresponds to changing the premise of the learning, by expanding (or constricting) the learning domain of level 1.
4. The meta-learning level corresponds to learning the best way to learn the operation in level 1
5. The lowest intelligence level (conscious decisions) that uses a training set to learn a particular task, e.g. learning to play tic-tac-toe.
